// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../selector.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StartButtonSelectorState {
  bool get isInit => throw _privateConstructorUsedError;
  bool get hasProfile => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StartButtonSelectorStateCopyWith<StartButtonSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StartButtonSelectorStateCopyWith<$Res> {
  factory $StartButtonSelectorStateCopyWith(StartButtonSelectorState value,
          $Res Function(StartButtonSelectorState) then) =
      _$StartButtonSelectorStateCopyWithImpl<$Res, StartButtonSelectorState>;
  @useResult
  $Res call({bool isInit, bool hasProfile});
}

/// @nodoc
class _$StartButtonSelectorStateCopyWithImpl<$Res,
        $Val extends StartButtonSelectorState>
    implements $StartButtonSelectorStateCopyWith<$Res> {
  _$StartButtonSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isInit = null,
    Object? hasProfile = null,
  }) {
    return _then(_value.copyWith(
      isInit: null == isInit
          ? _value.isInit
          : isInit // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProfile: null == hasProfile
          ? _value.hasProfile
          : hasProfile // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StartButtonSelectorStateImplCopyWith<$Res>
    implements $StartButtonSelectorStateCopyWith<$Res> {
  factory _$$StartButtonSelectorStateImplCopyWith(
          _$StartButtonSelectorStateImpl value,
          $Res Function(_$StartButtonSelectorStateImpl) then) =
      __$$StartButtonSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isInit, bool hasProfile});
}

/// @nodoc
class __$$StartButtonSelectorStateImplCopyWithImpl<$Res>
    extends _$StartButtonSelectorStateCopyWithImpl<$Res,
        _$StartButtonSelectorStateImpl>
    implements _$$StartButtonSelectorStateImplCopyWith<$Res> {
  __$$StartButtonSelectorStateImplCopyWithImpl(
      _$StartButtonSelectorStateImpl _value,
      $Res Function(_$StartButtonSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isInit = null,
    Object? hasProfile = null,
  }) {
    return _then(_$StartButtonSelectorStateImpl(
      isInit: null == isInit
          ? _value.isInit
          : isInit // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProfile: null == hasProfile
          ? _value.hasProfile
          : hasProfile // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$StartButtonSelectorStateImpl implements _StartButtonSelectorState {
  const _$StartButtonSelectorStateImpl(
      {required this.isInit, required this.hasProfile});

  @override
  final bool isInit;
  @override
  final bool hasProfile;

  @override
  String toString() {
    return 'StartButtonSelectorState(isInit: $isInit, hasProfile: $hasProfile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartButtonSelectorStateImpl &&
            (identical(other.isInit, isInit) || other.isInit == isInit) &&
            (identical(other.hasProfile, hasProfile) ||
                other.hasProfile == hasProfile));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isInit, hasProfile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StartButtonSelectorStateImplCopyWith<_$StartButtonSelectorStateImpl>
      get copyWith => __$$StartButtonSelectorStateImplCopyWithImpl<
          _$StartButtonSelectorStateImpl>(this, _$identity);
}

abstract class _StartButtonSelectorState implements StartButtonSelectorState {
  const factory _StartButtonSelectorState(
      {required final bool isInit,
      required final bool hasProfile}) = _$StartButtonSelectorStateImpl;

  @override
  bool get isInit;
  @override
  bool get hasProfile;
  @override
  @JsonKey(ignore: true)
  _$$StartButtonSelectorStateImplCopyWith<_$StartButtonSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CheckIpSelectorState {
  String? get currentProfileId => throw _privateConstructorUsedError;
  Map<String, String> get selectedMap => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CheckIpSelectorStateCopyWith<CheckIpSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CheckIpSelectorStateCopyWith<$Res> {
  factory $CheckIpSelectorStateCopyWith(CheckIpSelectorState value,
          $Res Function(CheckIpSelectorState) then) =
      _$CheckIpSelectorStateCopyWithImpl<$Res, CheckIpSelectorState>;
  @useResult
  $Res call({String? currentProfileId, Map<String, String> selectedMap});
}

/// @nodoc
class _$CheckIpSelectorStateCopyWithImpl<$Res,
        $Val extends CheckIpSelectorState>
    implements $CheckIpSelectorStateCopyWith<$Res> {
  _$CheckIpSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentProfileId = freezed,
    Object? selectedMap = null,
  }) {
    return _then(_value.copyWith(
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      selectedMap: null == selectedMap
          ? _value.selectedMap
          : selectedMap // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CheckIpSelectorStateImplCopyWith<$Res>
    implements $CheckIpSelectorStateCopyWith<$Res> {
  factory _$$CheckIpSelectorStateImplCopyWith(_$CheckIpSelectorStateImpl value,
          $Res Function(_$CheckIpSelectorStateImpl) then) =
      __$$CheckIpSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? currentProfileId, Map<String, String> selectedMap});
}

/// @nodoc
class __$$CheckIpSelectorStateImplCopyWithImpl<$Res>
    extends _$CheckIpSelectorStateCopyWithImpl<$Res, _$CheckIpSelectorStateImpl>
    implements _$$CheckIpSelectorStateImplCopyWith<$Res> {
  __$$CheckIpSelectorStateImplCopyWithImpl(_$CheckIpSelectorStateImpl _value,
      $Res Function(_$CheckIpSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentProfileId = freezed,
    Object? selectedMap = null,
  }) {
    return _then(_$CheckIpSelectorStateImpl(
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      selectedMap: null == selectedMap
          ? _value._selectedMap
          : selectedMap // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$CheckIpSelectorStateImpl implements _CheckIpSelectorState {
  const _$CheckIpSelectorStateImpl(
      {required this.currentProfileId,
      required final Map<String, String> selectedMap})
      : _selectedMap = selectedMap;

  @override
  final String? currentProfileId;
  final Map<String, String> _selectedMap;
  @override
  Map<String, String> get selectedMap {
    if (_selectedMap is EqualUnmodifiableMapView) return _selectedMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_selectedMap);
  }

  @override
  String toString() {
    return 'CheckIpSelectorState(currentProfileId: $currentProfileId, selectedMap: $selectedMap)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CheckIpSelectorStateImpl &&
            (identical(other.currentProfileId, currentProfileId) ||
                other.currentProfileId == currentProfileId) &&
            const DeepCollectionEquality()
                .equals(other._selectedMap, _selectedMap));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currentProfileId,
      const DeepCollectionEquality().hash(_selectedMap));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CheckIpSelectorStateImplCopyWith<_$CheckIpSelectorStateImpl>
      get copyWith =>
          __$$CheckIpSelectorStateImplCopyWithImpl<_$CheckIpSelectorStateImpl>(
              this, _$identity);
}

abstract class _CheckIpSelectorState implements CheckIpSelectorState {
  const factory _CheckIpSelectorState(
          {required final String? currentProfileId,
          required final Map<String, String> selectedMap}) =
      _$CheckIpSelectorStateImpl;

  @override
  String? get currentProfileId;
  @override
  Map<String, String> get selectedMap;
  @override
  @JsonKey(ignore: true)
  _$$CheckIpSelectorStateImplCopyWith<_$CheckIpSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NetworkDetectionSelectorState {
  String? get currentProxyName => throw _privateConstructorUsedError;
  int? get delay => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NetworkDetectionSelectorStateCopyWith<NetworkDetectionSelectorState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkDetectionSelectorStateCopyWith<$Res> {
  factory $NetworkDetectionSelectorStateCopyWith(
          NetworkDetectionSelectorState value,
          $Res Function(NetworkDetectionSelectorState) then) =
      _$NetworkDetectionSelectorStateCopyWithImpl<$Res,
          NetworkDetectionSelectorState>;
  @useResult
  $Res call({String? currentProxyName, int? delay});
}

/// @nodoc
class _$NetworkDetectionSelectorStateCopyWithImpl<$Res,
        $Val extends NetworkDetectionSelectorState>
    implements $NetworkDetectionSelectorStateCopyWith<$Res> {
  _$NetworkDetectionSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentProxyName = freezed,
    Object? delay = freezed,
  }) {
    return _then(_value.copyWith(
      currentProxyName: freezed == currentProxyName
          ? _value.currentProxyName
          : currentProxyName // ignore: cast_nullable_to_non_nullable
              as String?,
      delay: freezed == delay
          ? _value.delay
          : delay // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NetworkDetectionSelectorStateImplCopyWith<$Res>
    implements $NetworkDetectionSelectorStateCopyWith<$Res> {
  factory _$$NetworkDetectionSelectorStateImplCopyWith(
          _$NetworkDetectionSelectorStateImpl value,
          $Res Function(_$NetworkDetectionSelectorStateImpl) then) =
      __$$NetworkDetectionSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? currentProxyName, int? delay});
}

/// @nodoc
class __$$NetworkDetectionSelectorStateImplCopyWithImpl<$Res>
    extends _$NetworkDetectionSelectorStateCopyWithImpl<$Res,
        _$NetworkDetectionSelectorStateImpl>
    implements _$$NetworkDetectionSelectorStateImplCopyWith<$Res> {
  __$$NetworkDetectionSelectorStateImplCopyWithImpl(
      _$NetworkDetectionSelectorStateImpl _value,
      $Res Function(_$NetworkDetectionSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentProxyName = freezed,
    Object? delay = freezed,
  }) {
    return _then(_$NetworkDetectionSelectorStateImpl(
      currentProxyName: freezed == currentProxyName
          ? _value.currentProxyName
          : currentProxyName // ignore: cast_nullable_to_non_nullable
              as String?,
      delay: freezed == delay
          ? _value.delay
          : delay // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$NetworkDetectionSelectorStateImpl
    implements _NetworkDetectionSelectorState {
  const _$NetworkDetectionSelectorStateImpl(
      {required this.currentProxyName, required this.delay});

  @override
  final String? currentProxyName;
  @override
  final int? delay;

  @override
  String toString() {
    return 'NetworkDetectionSelectorState(currentProxyName: $currentProxyName, delay: $delay)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NetworkDetectionSelectorStateImpl &&
            (identical(other.currentProxyName, currentProxyName) ||
                other.currentProxyName == currentProxyName) &&
            (identical(other.delay, delay) || other.delay == delay));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currentProxyName, delay);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NetworkDetectionSelectorStateImplCopyWith<
          _$NetworkDetectionSelectorStateImpl>
      get copyWith => __$$NetworkDetectionSelectorStateImplCopyWithImpl<
          _$NetworkDetectionSelectorStateImpl>(this, _$identity);
}

abstract class _NetworkDetectionSelectorState
    implements NetworkDetectionSelectorState {
  const factory _NetworkDetectionSelectorState(
      {required final String? currentProxyName,
      required final int? delay}) = _$NetworkDetectionSelectorStateImpl;

  @override
  String? get currentProxyName;
  @override
  int? get delay;
  @override
  @JsonKey(ignore: true)
  _$$NetworkDetectionSelectorStateImplCopyWith<
          _$NetworkDetectionSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProfilesSelectorState {
  List<Profile> get profiles => throw _privateConstructorUsedError;
  String? get currentProfileId => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProfilesSelectorStateCopyWith<ProfilesSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProfilesSelectorStateCopyWith<$Res> {
  factory $ProfilesSelectorStateCopyWith(ProfilesSelectorState value,
          $Res Function(ProfilesSelectorState) then) =
      _$ProfilesSelectorStateCopyWithImpl<$Res, ProfilesSelectorState>;
  @useResult
  $Res call({List<Profile> profiles, String? currentProfileId, int columns});
}

/// @nodoc
class _$ProfilesSelectorStateCopyWithImpl<$Res,
        $Val extends ProfilesSelectorState>
    implements $ProfilesSelectorStateCopyWith<$Res> {
  _$ProfilesSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? profiles = null,
    Object? currentProfileId = freezed,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      profiles: null == profiles
          ? _value.profiles
          : profiles // ignore: cast_nullable_to_non_nullable
              as List<Profile>,
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProfilesSelectorStateImplCopyWith<$Res>
    implements $ProfilesSelectorStateCopyWith<$Res> {
  factory _$$ProfilesSelectorStateImplCopyWith(
          _$ProfilesSelectorStateImpl value,
          $Res Function(_$ProfilesSelectorStateImpl) then) =
      __$$ProfilesSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Profile> profiles, String? currentProfileId, int columns});
}

/// @nodoc
class __$$ProfilesSelectorStateImplCopyWithImpl<$Res>
    extends _$ProfilesSelectorStateCopyWithImpl<$Res,
        _$ProfilesSelectorStateImpl>
    implements _$$ProfilesSelectorStateImplCopyWith<$Res> {
  __$$ProfilesSelectorStateImplCopyWithImpl(_$ProfilesSelectorStateImpl _value,
      $Res Function(_$ProfilesSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? profiles = null,
    Object? currentProfileId = freezed,
    Object? columns = null,
  }) {
    return _then(_$ProfilesSelectorStateImpl(
      profiles: null == profiles
          ? _value._profiles
          : profiles // ignore: cast_nullable_to_non_nullable
              as List<Profile>,
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProfilesSelectorStateImpl implements _ProfilesSelectorState {
  const _$ProfilesSelectorStateImpl(
      {required final List<Profile> profiles,
      required this.currentProfileId,
      required this.columns})
      : _profiles = profiles;

  final List<Profile> _profiles;
  @override
  List<Profile> get profiles {
    if (_profiles is EqualUnmodifiableListView) return _profiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_profiles);
  }

  @override
  final String? currentProfileId;
  @override
  final int columns;

  @override
  String toString() {
    return 'ProfilesSelectorState(profiles: $profiles, currentProfileId: $currentProfileId, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProfilesSelectorStateImpl &&
            const DeepCollectionEquality().equals(other._profiles, _profiles) &&
            (identical(other.currentProfileId, currentProfileId) ||
                other.currentProfileId == currentProfileId) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_profiles),
      currentProfileId,
      columns);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProfilesSelectorStateImplCopyWith<_$ProfilesSelectorStateImpl>
      get copyWith => __$$ProfilesSelectorStateImplCopyWithImpl<
          _$ProfilesSelectorStateImpl>(this, _$identity);
}

abstract class _ProfilesSelectorState implements ProfilesSelectorState {
  const factory _ProfilesSelectorState(
      {required final List<Profile> profiles,
      required final String? currentProfileId,
      required final int columns}) = _$ProfilesSelectorStateImpl;

  @override
  List<Profile> get profiles;
  @override
  String? get currentProfileId;
  @override
  int get columns;
  @override
  @JsonKey(ignore: true)
  _$$ProfilesSelectorStateImplCopyWith<_$ProfilesSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NetworkDetectionState {
  bool get isTesting => throw _privateConstructorUsedError;
  IpInfo? get ipInfo => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NetworkDetectionStateCopyWith<NetworkDetectionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkDetectionStateCopyWith<$Res> {
  factory $NetworkDetectionStateCopyWith(NetworkDetectionState value,
          $Res Function(NetworkDetectionState) then) =
      _$NetworkDetectionStateCopyWithImpl<$Res, NetworkDetectionState>;
  @useResult
  $Res call({bool isTesting, IpInfo? ipInfo});
}

/// @nodoc
class _$NetworkDetectionStateCopyWithImpl<$Res,
        $Val extends NetworkDetectionState>
    implements $NetworkDetectionStateCopyWith<$Res> {
  _$NetworkDetectionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isTesting = null,
    Object? ipInfo = freezed,
  }) {
    return _then(_value.copyWith(
      isTesting: null == isTesting
          ? _value.isTesting
          : isTesting // ignore: cast_nullable_to_non_nullable
              as bool,
      ipInfo: freezed == ipInfo
          ? _value.ipInfo
          : ipInfo // ignore: cast_nullable_to_non_nullable
              as IpInfo?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NetworkDetectionStateImplCopyWith<$Res>
    implements $NetworkDetectionStateCopyWith<$Res> {
  factory _$$NetworkDetectionStateImplCopyWith(
          _$NetworkDetectionStateImpl value,
          $Res Function(_$NetworkDetectionStateImpl) then) =
      __$$NetworkDetectionStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isTesting, IpInfo? ipInfo});
}

/// @nodoc
class __$$NetworkDetectionStateImplCopyWithImpl<$Res>
    extends _$NetworkDetectionStateCopyWithImpl<$Res,
        _$NetworkDetectionStateImpl>
    implements _$$NetworkDetectionStateImplCopyWith<$Res> {
  __$$NetworkDetectionStateImplCopyWithImpl(_$NetworkDetectionStateImpl _value,
      $Res Function(_$NetworkDetectionStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isTesting = null,
    Object? ipInfo = freezed,
  }) {
    return _then(_$NetworkDetectionStateImpl(
      isTesting: null == isTesting
          ? _value.isTesting
          : isTesting // ignore: cast_nullable_to_non_nullable
              as bool,
      ipInfo: freezed == ipInfo
          ? _value.ipInfo
          : ipInfo // ignore: cast_nullable_to_non_nullable
              as IpInfo?,
    ));
  }
}

/// @nodoc

class _$NetworkDetectionStateImpl implements _NetworkDetectionState {
  const _$NetworkDetectionStateImpl(
      {required this.isTesting, required this.ipInfo});

  @override
  final bool isTesting;
  @override
  final IpInfo? ipInfo;

  @override
  String toString() {
    return 'NetworkDetectionState(isTesting: $isTesting, ipInfo: $ipInfo)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NetworkDetectionStateImpl &&
            (identical(other.isTesting, isTesting) ||
                other.isTesting == isTesting) &&
            (identical(other.ipInfo, ipInfo) || other.ipInfo == ipInfo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isTesting, ipInfo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NetworkDetectionStateImplCopyWith<_$NetworkDetectionStateImpl>
      get copyWith => __$$NetworkDetectionStateImplCopyWithImpl<
          _$NetworkDetectionStateImpl>(this, _$identity);
}

abstract class _NetworkDetectionState implements NetworkDetectionState {
  const factory _NetworkDetectionState(
      {required final bool isTesting,
      required final IpInfo? ipInfo}) = _$NetworkDetectionStateImpl;

  @override
  bool get isTesting;
  @override
  IpInfo? get ipInfo;
  @override
  @JsonKey(ignore: true)
  _$$NetworkDetectionStateImplCopyWith<_$NetworkDetectionStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ApplicationSelectorState {
  String? get locale => throw _privateConstructorUsedError;
  ThemeMode? get themeMode => throw _privateConstructorUsedError;
  int? get primaryColor => throw _privateConstructorUsedError;
  bool get prueBlack => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ApplicationSelectorStateCopyWith<ApplicationSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApplicationSelectorStateCopyWith<$Res> {
  factory $ApplicationSelectorStateCopyWith(ApplicationSelectorState value,
          $Res Function(ApplicationSelectorState) then) =
      _$ApplicationSelectorStateCopyWithImpl<$Res, ApplicationSelectorState>;
  @useResult
  $Res call(
      {String? locale,
      ThemeMode? themeMode,
      int? primaryColor,
      bool prueBlack});
}

/// @nodoc
class _$ApplicationSelectorStateCopyWithImpl<$Res,
        $Val extends ApplicationSelectorState>
    implements $ApplicationSelectorStateCopyWith<$Res> {
  _$ApplicationSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? locale = freezed,
    Object? themeMode = freezed,
    Object? primaryColor = freezed,
    Object? prueBlack = null,
  }) {
    return _then(_value.copyWith(
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      themeMode: freezed == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode?,
      primaryColor: freezed == primaryColor
          ? _value.primaryColor
          : primaryColor // ignore: cast_nullable_to_non_nullable
              as int?,
      prueBlack: null == prueBlack
          ? _value.prueBlack
          : prueBlack // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ApplicationSelectorStateImplCopyWith<$Res>
    implements $ApplicationSelectorStateCopyWith<$Res> {
  factory _$$ApplicationSelectorStateImplCopyWith(
          _$ApplicationSelectorStateImpl value,
          $Res Function(_$ApplicationSelectorStateImpl) then) =
      __$$ApplicationSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? locale,
      ThemeMode? themeMode,
      int? primaryColor,
      bool prueBlack});
}

/// @nodoc
class __$$ApplicationSelectorStateImplCopyWithImpl<$Res>
    extends _$ApplicationSelectorStateCopyWithImpl<$Res,
        _$ApplicationSelectorStateImpl>
    implements _$$ApplicationSelectorStateImplCopyWith<$Res> {
  __$$ApplicationSelectorStateImplCopyWithImpl(
      _$ApplicationSelectorStateImpl _value,
      $Res Function(_$ApplicationSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? locale = freezed,
    Object? themeMode = freezed,
    Object? primaryColor = freezed,
    Object? prueBlack = null,
  }) {
    return _then(_$ApplicationSelectorStateImpl(
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      themeMode: freezed == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode?,
      primaryColor: freezed == primaryColor
          ? _value.primaryColor
          : primaryColor // ignore: cast_nullable_to_non_nullable
              as int?,
      prueBlack: null == prueBlack
          ? _value.prueBlack
          : prueBlack // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ApplicationSelectorStateImpl implements _ApplicationSelectorState {
  const _$ApplicationSelectorStateImpl(
      {required this.locale,
      required this.themeMode,
      required this.primaryColor,
      required this.prueBlack});

  @override
  final String? locale;
  @override
  final ThemeMode? themeMode;
  @override
  final int? primaryColor;
  @override
  final bool prueBlack;

  @override
  String toString() {
    return 'ApplicationSelectorState(locale: $locale, themeMode: $themeMode, primaryColor: $primaryColor, prueBlack: $prueBlack)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApplicationSelectorStateImpl &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.primaryColor, primaryColor) ||
                other.primaryColor == primaryColor) &&
            (identical(other.prueBlack, prueBlack) ||
                other.prueBlack == prueBlack));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, locale, themeMode, primaryColor, prueBlack);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ApplicationSelectorStateImplCopyWith<_$ApplicationSelectorStateImpl>
      get copyWith => __$$ApplicationSelectorStateImplCopyWithImpl<
          _$ApplicationSelectorStateImpl>(this, _$identity);
}

abstract class _ApplicationSelectorState implements ApplicationSelectorState {
  const factory _ApplicationSelectorState(
      {required final String? locale,
      required final ThemeMode? themeMode,
      required final int? primaryColor,
      required final bool prueBlack}) = _$ApplicationSelectorStateImpl;

  @override
  String? get locale;
  @override
  ThemeMode? get themeMode;
  @override
  int? get primaryColor;
  @override
  bool get prueBlack;
  @override
  @JsonKey(ignore: true)
  _$$ApplicationSelectorStateImplCopyWith<_$ApplicationSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrayContainerSelectorState {
  Mode get mode => throw _privateConstructorUsedError;
  bool get autoLaunch => throw _privateConstructorUsedError;
  bool get systemProxy => throw _privateConstructorUsedError;
  bool get tunEnable => throw _privateConstructorUsedError;
  bool get isStart => throw _privateConstructorUsedError;
  String? get locale => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TrayContainerSelectorStateCopyWith<TrayContainerSelectorState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrayContainerSelectorStateCopyWith<$Res> {
  factory $TrayContainerSelectorStateCopyWith(TrayContainerSelectorState value,
          $Res Function(TrayContainerSelectorState) then) =
      _$TrayContainerSelectorStateCopyWithImpl<$Res,
          TrayContainerSelectorState>;
  @useResult
  $Res call(
      {Mode mode,
      bool autoLaunch,
      bool systemProxy,
      bool tunEnable,
      bool isStart,
      String? locale});
}

/// @nodoc
class _$TrayContainerSelectorStateCopyWithImpl<$Res,
        $Val extends TrayContainerSelectorState>
    implements $TrayContainerSelectorStateCopyWith<$Res> {
  _$TrayContainerSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? autoLaunch = null,
    Object? systemProxy = null,
    Object? tunEnable = null,
    Object? isStart = null,
    Object? locale = freezed,
  }) {
    return _then(_value.copyWith(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      autoLaunch: null == autoLaunch
          ? _value.autoLaunch
          : autoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      tunEnable: null == tunEnable
          ? _value.tunEnable
          : tunEnable // ignore: cast_nullable_to_non_nullable
              as bool,
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TrayContainerSelectorStateImplCopyWith<$Res>
    implements $TrayContainerSelectorStateCopyWith<$Res> {
  factory _$$TrayContainerSelectorStateImplCopyWith(
          _$TrayContainerSelectorStateImpl value,
          $Res Function(_$TrayContainerSelectorStateImpl) then) =
      __$$TrayContainerSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Mode mode,
      bool autoLaunch,
      bool systemProxy,
      bool tunEnable,
      bool isStart,
      String? locale});
}

/// @nodoc
class __$$TrayContainerSelectorStateImplCopyWithImpl<$Res>
    extends _$TrayContainerSelectorStateCopyWithImpl<$Res,
        _$TrayContainerSelectorStateImpl>
    implements _$$TrayContainerSelectorStateImplCopyWith<$Res> {
  __$$TrayContainerSelectorStateImplCopyWithImpl(
      _$TrayContainerSelectorStateImpl _value,
      $Res Function(_$TrayContainerSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? autoLaunch = null,
    Object? systemProxy = null,
    Object? tunEnable = null,
    Object? isStart = null,
    Object? locale = freezed,
  }) {
    return _then(_$TrayContainerSelectorStateImpl(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      autoLaunch: null == autoLaunch
          ? _value.autoLaunch
          : autoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      tunEnable: null == tunEnable
          ? _value.tunEnable
          : tunEnable // ignore: cast_nullable_to_non_nullable
              as bool,
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$TrayContainerSelectorStateImpl implements _TrayContainerSelectorState {
  const _$TrayContainerSelectorStateImpl(
      {required this.mode,
      required this.autoLaunch,
      required this.systemProxy,
      required this.tunEnable,
      required this.isStart,
      required this.locale});

  @override
  final Mode mode;
  @override
  final bool autoLaunch;
  @override
  final bool systemProxy;
  @override
  final bool tunEnable;
  @override
  final bool isStart;
  @override
  final String? locale;

  @override
  String toString() {
    return 'TrayContainerSelectorState(mode: $mode, autoLaunch: $autoLaunch, systemProxy: $systemProxy, tunEnable: $tunEnable, isStart: $isStart, locale: $locale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrayContainerSelectorStateImpl &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.autoLaunch, autoLaunch) ||
                other.autoLaunch == autoLaunch) &&
            (identical(other.systemProxy, systemProxy) ||
                other.systemProxy == systemProxy) &&
            (identical(other.tunEnable, tunEnable) ||
                other.tunEnable == tunEnable) &&
            (identical(other.isStart, isStart) || other.isStart == isStart) &&
            (identical(other.locale, locale) || other.locale == locale));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, mode, autoLaunch, systemProxy, tunEnable, isStart, locale);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrayContainerSelectorStateImplCopyWith<_$TrayContainerSelectorStateImpl>
      get copyWith => __$$TrayContainerSelectorStateImplCopyWithImpl<
          _$TrayContainerSelectorStateImpl>(this, _$identity);
}

abstract class _TrayContainerSelectorState
    implements TrayContainerSelectorState {
  const factory _TrayContainerSelectorState(
      {required final Mode mode,
      required final bool autoLaunch,
      required final bool systemProxy,
      required final bool tunEnable,
      required final bool isStart,
      required final String? locale}) = _$TrayContainerSelectorStateImpl;

  @override
  Mode get mode;
  @override
  bool get autoLaunch;
  @override
  bool get systemProxy;
  @override
  bool get tunEnable;
  @override
  bool get isStart;
  @override
  String? get locale;
  @override
  @JsonKey(ignore: true)
  _$$TrayContainerSelectorStateImplCopyWith<_$TrayContainerSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UpdateNavigationsSelector {
  bool get openLogs => throw _privateConstructorUsedError;
  bool get hasProxies => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UpdateNavigationsSelectorCopyWith<UpdateNavigationsSelector> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateNavigationsSelectorCopyWith<$Res> {
  factory $UpdateNavigationsSelectorCopyWith(UpdateNavigationsSelector value,
          $Res Function(UpdateNavigationsSelector) then) =
      _$UpdateNavigationsSelectorCopyWithImpl<$Res, UpdateNavigationsSelector>;
  @useResult
  $Res call({bool openLogs, bool hasProxies});
}

/// @nodoc
class _$UpdateNavigationsSelectorCopyWithImpl<$Res,
        $Val extends UpdateNavigationsSelector>
    implements $UpdateNavigationsSelectorCopyWith<$Res> {
  _$UpdateNavigationsSelectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? openLogs = null,
    Object? hasProxies = null,
  }) {
    return _then(_value.copyWith(
      openLogs: null == openLogs
          ? _value.openLogs
          : openLogs // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProxies: null == hasProxies
          ? _value.hasProxies
          : hasProxies // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UpdateNavigationsSelectorImplCopyWith<$Res>
    implements $UpdateNavigationsSelectorCopyWith<$Res> {
  factory _$$UpdateNavigationsSelectorImplCopyWith(
          _$UpdateNavigationsSelectorImpl value,
          $Res Function(_$UpdateNavigationsSelectorImpl) then) =
      __$$UpdateNavigationsSelectorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool openLogs, bool hasProxies});
}

/// @nodoc
class __$$UpdateNavigationsSelectorImplCopyWithImpl<$Res>
    extends _$UpdateNavigationsSelectorCopyWithImpl<$Res,
        _$UpdateNavigationsSelectorImpl>
    implements _$$UpdateNavigationsSelectorImplCopyWith<$Res> {
  __$$UpdateNavigationsSelectorImplCopyWithImpl(
      _$UpdateNavigationsSelectorImpl _value,
      $Res Function(_$UpdateNavigationsSelectorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? openLogs = null,
    Object? hasProxies = null,
  }) {
    return _then(_$UpdateNavigationsSelectorImpl(
      openLogs: null == openLogs
          ? _value.openLogs
          : openLogs // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProxies: null == hasProxies
          ? _value.hasProxies
          : hasProxies // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateNavigationsSelectorImpl implements _UpdateNavigationsSelector {
  const _$UpdateNavigationsSelectorImpl(
      {required this.openLogs, required this.hasProxies});

  @override
  final bool openLogs;
  @override
  final bool hasProxies;

  @override
  String toString() {
    return 'UpdateNavigationsSelector(openLogs: $openLogs, hasProxies: $hasProxies)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateNavigationsSelectorImpl &&
            (identical(other.openLogs, openLogs) ||
                other.openLogs == openLogs) &&
            (identical(other.hasProxies, hasProxies) ||
                other.hasProxies == hasProxies));
  }

  @override
  int get hashCode => Object.hash(runtimeType, openLogs, hasProxies);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateNavigationsSelectorImplCopyWith<_$UpdateNavigationsSelectorImpl>
      get copyWith => __$$UpdateNavigationsSelectorImplCopyWithImpl<
          _$UpdateNavigationsSelectorImpl>(this, _$identity);
}

abstract class _UpdateNavigationsSelector implements UpdateNavigationsSelector {
  const factory _UpdateNavigationsSelector(
      {required final bool openLogs,
      required final bool hasProxies}) = _$UpdateNavigationsSelectorImpl;

  @override
  bool get openLogs;
  @override
  bool get hasProxies;
  @override
  @JsonKey(ignore: true)
  _$$UpdateNavigationsSelectorImplCopyWith<_$UpdateNavigationsSelectorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HomeSelectorState {
  String get currentLabel => throw _privateConstructorUsedError;
  List<NavigationItem> get navigationItems =>
      throw _privateConstructorUsedError;
  ViewMode get viewMode => throw _privateConstructorUsedError;
  String? get locale => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HomeSelectorStateCopyWith<HomeSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeSelectorStateCopyWith<$Res> {
  factory $HomeSelectorStateCopyWith(
          HomeSelectorState value, $Res Function(HomeSelectorState) then) =
      _$HomeSelectorStateCopyWithImpl<$Res, HomeSelectorState>;
  @useResult
  $Res call(
      {String currentLabel,
      List<NavigationItem> navigationItems,
      ViewMode viewMode,
      String? locale});
}

/// @nodoc
class _$HomeSelectorStateCopyWithImpl<$Res, $Val extends HomeSelectorState>
    implements $HomeSelectorStateCopyWith<$Res> {
  _$HomeSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentLabel = null,
    Object? navigationItems = null,
    Object? viewMode = null,
    Object? locale = freezed,
  }) {
    return _then(_value.copyWith(
      currentLabel: null == currentLabel
          ? _value.currentLabel
          : currentLabel // ignore: cast_nullable_to_non_nullable
              as String,
      navigationItems: null == navigationItems
          ? _value.navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
      viewMode: null == viewMode
          ? _value.viewMode
          : viewMode // ignore: cast_nullable_to_non_nullable
              as ViewMode,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HomeSelectorStateImplCopyWith<$Res>
    implements $HomeSelectorStateCopyWith<$Res> {
  factory _$$HomeSelectorStateImplCopyWith(_$HomeSelectorStateImpl value,
          $Res Function(_$HomeSelectorStateImpl) then) =
      __$$HomeSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String currentLabel,
      List<NavigationItem> navigationItems,
      ViewMode viewMode,
      String? locale});
}

/// @nodoc
class __$$HomeSelectorStateImplCopyWithImpl<$Res>
    extends _$HomeSelectorStateCopyWithImpl<$Res, _$HomeSelectorStateImpl>
    implements _$$HomeSelectorStateImplCopyWith<$Res> {
  __$$HomeSelectorStateImplCopyWithImpl(_$HomeSelectorStateImpl _value,
      $Res Function(_$HomeSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentLabel = null,
    Object? navigationItems = null,
    Object? viewMode = null,
    Object? locale = freezed,
  }) {
    return _then(_$HomeSelectorStateImpl(
      currentLabel: null == currentLabel
          ? _value.currentLabel
          : currentLabel // ignore: cast_nullable_to_non_nullable
              as String,
      navigationItems: null == navigationItems
          ? _value._navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
      viewMode: null == viewMode
          ? _value.viewMode
          : viewMode // ignore: cast_nullable_to_non_nullable
              as ViewMode,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$HomeSelectorStateImpl implements _HomeSelectorState {
  const _$HomeSelectorStateImpl(
      {required this.currentLabel,
      required final List<NavigationItem> navigationItems,
      required this.viewMode,
      required this.locale})
      : _navigationItems = navigationItems;

  @override
  final String currentLabel;
  final List<NavigationItem> _navigationItems;
  @override
  List<NavigationItem> get navigationItems {
    if (_navigationItems is EqualUnmodifiableListView) return _navigationItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_navigationItems);
  }

  @override
  final ViewMode viewMode;
  @override
  final String? locale;

  @override
  String toString() {
    return 'HomeSelectorState(currentLabel: $currentLabel, navigationItems: $navigationItems, viewMode: $viewMode, locale: $locale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeSelectorStateImpl &&
            (identical(other.currentLabel, currentLabel) ||
                other.currentLabel == currentLabel) &&
            const DeepCollectionEquality()
                .equals(other._navigationItems, _navigationItems) &&
            (identical(other.viewMode, viewMode) ||
                other.viewMode == viewMode) &&
            (identical(other.locale, locale) || other.locale == locale));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currentLabel,
      const DeepCollectionEquality().hash(_navigationItems), viewMode, locale);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeSelectorStateImplCopyWith<_$HomeSelectorStateImpl> get copyWith =>
      __$$HomeSelectorStateImplCopyWithImpl<_$HomeSelectorStateImpl>(
          this, _$identity);
}

abstract class _HomeSelectorState implements HomeSelectorState {
  const factory _HomeSelectorState(
      {required final String currentLabel,
      required final List<NavigationItem> navigationItems,
      required final ViewMode viewMode,
      required final String? locale}) = _$HomeSelectorStateImpl;

  @override
  String get currentLabel;
  @override
  List<NavigationItem> get navigationItems;
  @override
  ViewMode get viewMode;
  @override
  String? get locale;
  @override
  @JsonKey(ignore: true)
  _$$HomeSelectorStateImplCopyWith<_$HomeSelectorStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HomeBodySelectorState {
  List<NavigationItem> get navigationItems =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HomeBodySelectorStateCopyWith<HomeBodySelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeBodySelectorStateCopyWith<$Res> {
  factory $HomeBodySelectorStateCopyWith(HomeBodySelectorState value,
          $Res Function(HomeBodySelectorState) then) =
      _$HomeBodySelectorStateCopyWithImpl<$Res, HomeBodySelectorState>;
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class _$HomeBodySelectorStateCopyWithImpl<$Res,
        $Val extends HomeBodySelectorState>
    implements $HomeBodySelectorStateCopyWith<$Res> {
  _$HomeBodySelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_value.copyWith(
      navigationItems: null == navigationItems
          ? _value.navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HomeBodySelectorStateImplCopyWith<$Res>
    implements $HomeBodySelectorStateCopyWith<$Res> {
  factory _$$HomeBodySelectorStateImplCopyWith(
          _$HomeBodySelectorStateImpl value,
          $Res Function(_$HomeBodySelectorStateImpl) then) =
      __$$HomeBodySelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class __$$HomeBodySelectorStateImplCopyWithImpl<$Res>
    extends _$HomeBodySelectorStateCopyWithImpl<$Res,
        _$HomeBodySelectorStateImpl>
    implements _$$HomeBodySelectorStateImplCopyWith<$Res> {
  __$$HomeBodySelectorStateImplCopyWithImpl(_$HomeBodySelectorStateImpl _value,
      $Res Function(_$HomeBodySelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_$HomeBodySelectorStateImpl(
      navigationItems: null == navigationItems
          ? _value._navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ));
  }
}

/// @nodoc

class _$HomeBodySelectorStateImpl implements _HomeBodySelectorState {
  const _$HomeBodySelectorStateImpl(
      {required final List<NavigationItem> navigationItems})
      : _navigationItems = navigationItems;

  final List<NavigationItem> _navigationItems;
  @override
  List<NavigationItem> get navigationItems {
    if (_navigationItems is EqualUnmodifiableListView) return _navigationItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_navigationItems);
  }

  @override
  String toString() {
    return 'HomeBodySelectorState(navigationItems: $navigationItems)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeBodySelectorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._navigationItems, _navigationItems));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_navigationItems));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeBodySelectorStateImplCopyWith<_$HomeBodySelectorStateImpl>
      get copyWith => __$$HomeBodySelectorStateImplCopyWithImpl<
          _$HomeBodySelectorStateImpl>(this, _$identity);
}

abstract class _HomeBodySelectorState implements HomeBodySelectorState {
  const factory _HomeBodySelectorState(
          {required final List<NavigationItem> navigationItems}) =
      _$HomeBodySelectorStateImpl;

  @override
  List<NavigationItem> get navigationItems;
  @override
  @JsonKey(ignore: true)
  _$$HomeBodySelectorStateImplCopyWith<_$HomeBodySelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesCardSelectorState {
  bool get isSelected => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxiesCardSelectorStateCopyWith<ProxiesCardSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesCardSelectorStateCopyWith<$Res> {
  factory $ProxiesCardSelectorStateCopyWith(ProxiesCardSelectorState value,
          $Res Function(ProxiesCardSelectorState) then) =
      _$ProxiesCardSelectorStateCopyWithImpl<$Res, ProxiesCardSelectorState>;
  @useResult
  $Res call({bool isSelected});
}

/// @nodoc
class _$ProxiesCardSelectorStateCopyWithImpl<$Res,
        $Val extends ProxiesCardSelectorState>
    implements $ProxiesCardSelectorStateCopyWith<$Res> {
  _$ProxiesCardSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSelected = null,
  }) {
    return _then(_value.copyWith(
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesCardSelectorStateImplCopyWith<$Res>
    implements $ProxiesCardSelectorStateCopyWith<$Res> {
  factory _$$ProxiesCardSelectorStateImplCopyWith(
          _$ProxiesCardSelectorStateImpl value,
          $Res Function(_$ProxiesCardSelectorStateImpl) then) =
      __$$ProxiesCardSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isSelected});
}

/// @nodoc
class __$$ProxiesCardSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxiesCardSelectorStateCopyWithImpl<$Res,
        _$ProxiesCardSelectorStateImpl>
    implements _$$ProxiesCardSelectorStateImplCopyWith<$Res> {
  __$$ProxiesCardSelectorStateImplCopyWithImpl(
      _$ProxiesCardSelectorStateImpl _value,
      $Res Function(_$ProxiesCardSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSelected = null,
  }) {
    return _then(_$ProxiesCardSelectorStateImpl(
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProxiesCardSelectorStateImpl implements _ProxiesCardSelectorState {
  const _$ProxiesCardSelectorStateImpl({required this.isSelected});

  @override
  final bool isSelected;

  @override
  String toString() {
    return 'ProxiesCardSelectorState(isSelected: $isSelected)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesCardSelectorStateImpl &&
            (identical(other.isSelected, isSelected) ||
                other.isSelected == isSelected));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isSelected);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesCardSelectorStateImplCopyWith<_$ProxiesCardSelectorStateImpl>
      get copyWith => __$$ProxiesCardSelectorStateImplCopyWithImpl<
          _$ProxiesCardSelectorStateImpl>(this, _$identity);
}

abstract class _ProxiesCardSelectorState implements ProxiesCardSelectorState {
  const factory _ProxiesCardSelectorState({required final bool isSelected}) =
      _$ProxiesCardSelectorStateImpl;

  @override
  bool get isSelected;
  @override
  @JsonKey(ignore: true)
  _$$ProxiesCardSelectorStateImplCopyWith<_$ProxiesCardSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesSelectorState {
  List<String> get groupNames => throw _privateConstructorUsedError;
  String? get currentGroupName => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxiesSelectorStateCopyWith<ProxiesSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesSelectorStateCopyWith<$Res> {
  factory $ProxiesSelectorStateCopyWith(ProxiesSelectorState value,
          $Res Function(ProxiesSelectorState) then) =
      _$ProxiesSelectorStateCopyWithImpl<$Res, ProxiesSelectorState>;
  @useResult
  $Res call({List<String> groupNames, String? currentGroupName});
}

/// @nodoc
class _$ProxiesSelectorStateCopyWithImpl<$Res,
        $Val extends ProxiesSelectorState>
    implements $ProxiesSelectorStateCopyWith<$Res> {
  _$ProxiesSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupNames = null,
    Object? currentGroupName = freezed,
  }) {
    return _then(_value.copyWith(
      groupNames: null == groupNames
          ? _value.groupNames
          : groupNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentGroupName: freezed == currentGroupName
          ? _value.currentGroupName
          : currentGroupName // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesSelectorStateImplCopyWith<$Res>
    implements $ProxiesSelectorStateCopyWith<$Res> {
  factory _$$ProxiesSelectorStateImplCopyWith(_$ProxiesSelectorStateImpl value,
          $Res Function(_$ProxiesSelectorStateImpl) then) =
      __$$ProxiesSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> groupNames, String? currentGroupName});
}

/// @nodoc
class __$$ProxiesSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxiesSelectorStateCopyWithImpl<$Res, _$ProxiesSelectorStateImpl>
    implements _$$ProxiesSelectorStateImplCopyWith<$Res> {
  __$$ProxiesSelectorStateImplCopyWithImpl(_$ProxiesSelectorStateImpl _value,
      $Res Function(_$ProxiesSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupNames = null,
    Object? currentGroupName = freezed,
  }) {
    return _then(_$ProxiesSelectorStateImpl(
      groupNames: null == groupNames
          ? _value._groupNames
          : groupNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentGroupName: freezed == currentGroupName
          ? _value.currentGroupName
          : currentGroupName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ProxiesSelectorStateImpl implements _ProxiesSelectorState {
  const _$ProxiesSelectorStateImpl(
      {required final List<String> groupNames, required this.currentGroupName})
      : _groupNames = groupNames;

  final List<String> _groupNames;
  @override
  List<String> get groupNames {
    if (_groupNames is EqualUnmodifiableListView) return _groupNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groupNames);
  }

  @override
  final String? currentGroupName;

  @override
  String toString() {
    return 'ProxiesSelectorState(groupNames: $groupNames, currentGroupName: $currentGroupName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesSelectorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._groupNames, _groupNames) &&
            (identical(other.currentGroupName, currentGroupName) ||
                other.currentGroupName == currentGroupName));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_groupNames), currentGroupName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesSelectorStateImplCopyWith<_$ProxiesSelectorStateImpl>
      get copyWith =>
          __$$ProxiesSelectorStateImplCopyWithImpl<_$ProxiesSelectorStateImpl>(
              this, _$identity);
}

abstract class _ProxiesSelectorState implements ProxiesSelectorState {
  const factory _ProxiesSelectorState(
      {required final List<String> groupNames,
      required final String? currentGroupName}) = _$ProxiesSelectorStateImpl;

  @override
  List<String> get groupNames;
  @override
  String? get currentGroupName;
  @override
  @JsonKey(ignore: true)
  _$$ProxiesSelectorStateImplCopyWith<_$ProxiesSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesListSelectorState {
  List<String> get groupNames => throw _privateConstructorUsedError;
  Set<String> get currentUnfoldSet => throw _privateConstructorUsedError;
  ProxiesSortType get proxiesSortType => throw _privateConstructorUsedError;
  ProxyCardType get proxyCardType => throw _privateConstructorUsedError;
  num get sortNum => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxiesListSelectorStateCopyWith<ProxiesListSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesListSelectorStateCopyWith<$Res> {
  factory $ProxiesListSelectorStateCopyWith(ProxiesListSelectorState value,
          $Res Function(ProxiesListSelectorState) then) =
      _$ProxiesListSelectorStateCopyWithImpl<$Res, ProxiesListSelectorState>;
  @useResult
  $Res call(
      {List<String> groupNames,
      Set<String> currentUnfoldSet,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class _$ProxiesListSelectorStateCopyWithImpl<$Res,
        $Val extends ProxiesListSelectorState>
    implements $ProxiesListSelectorStateCopyWith<$Res> {
  _$ProxiesListSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupNames = null,
    Object? currentUnfoldSet = null,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      groupNames: null == groupNames
          ? _value.groupNames
          : groupNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentUnfoldSet: null == currentUnfoldSet
          ? _value.currentUnfoldSet
          : currentUnfoldSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesListSelectorStateImplCopyWith<$Res>
    implements $ProxiesListSelectorStateCopyWith<$Res> {
  factory _$$ProxiesListSelectorStateImplCopyWith(
          _$ProxiesListSelectorStateImpl value,
          $Res Function(_$ProxiesListSelectorStateImpl) then) =
      __$$ProxiesListSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String> groupNames,
      Set<String> currentUnfoldSet,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class __$$ProxiesListSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxiesListSelectorStateCopyWithImpl<$Res,
        _$ProxiesListSelectorStateImpl>
    implements _$$ProxiesListSelectorStateImplCopyWith<$Res> {
  __$$ProxiesListSelectorStateImplCopyWithImpl(
      _$ProxiesListSelectorStateImpl _value,
      $Res Function(_$ProxiesListSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupNames = null,
    Object? currentUnfoldSet = null,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_$ProxiesListSelectorStateImpl(
      groupNames: null == groupNames
          ? _value._groupNames
          : groupNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentUnfoldSet: null == currentUnfoldSet
          ? _value._currentUnfoldSet
          : currentUnfoldSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxiesListSelectorStateImpl implements _ProxiesListSelectorState {
  const _$ProxiesListSelectorStateImpl(
      {required final List<String> groupNames,
      required final Set<String> currentUnfoldSet,
      required this.proxiesSortType,
      required this.proxyCardType,
      required this.sortNum,
      required this.columns})
      : _groupNames = groupNames,
        _currentUnfoldSet = currentUnfoldSet;

  final List<String> _groupNames;
  @override
  List<String> get groupNames {
    if (_groupNames is EqualUnmodifiableListView) return _groupNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groupNames);
  }

  final Set<String> _currentUnfoldSet;
  @override
  Set<String> get currentUnfoldSet {
    if (_currentUnfoldSet is EqualUnmodifiableSetView) return _currentUnfoldSet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_currentUnfoldSet);
  }

  @override
  final ProxiesSortType proxiesSortType;
  @override
  final ProxyCardType proxyCardType;
  @override
  final num sortNum;
  @override
  final int columns;

  @override
  String toString() {
    return 'ProxiesListSelectorState(groupNames: $groupNames, currentUnfoldSet: $currentUnfoldSet, proxiesSortType: $proxiesSortType, proxyCardType: $proxyCardType, sortNum: $sortNum, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesListSelectorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._groupNames, _groupNames) &&
            const DeepCollectionEquality()
                .equals(other._currentUnfoldSet, _currentUnfoldSet) &&
            (identical(other.proxiesSortType, proxiesSortType) ||
                other.proxiesSortType == proxiesSortType) &&
            (identical(other.proxyCardType, proxyCardType) ||
                other.proxyCardType == proxyCardType) &&
            (identical(other.sortNum, sortNum) || other.sortNum == sortNum) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_groupNames),
      const DeepCollectionEquality().hash(_currentUnfoldSet),
      proxiesSortType,
      proxyCardType,
      sortNum,
      columns);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesListSelectorStateImplCopyWith<_$ProxiesListSelectorStateImpl>
      get copyWith => __$$ProxiesListSelectorStateImplCopyWithImpl<
          _$ProxiesListSelectorStateImpl>(this, _$identity);
}

abstract class _ProxiesListSelectorState implements ProxiesListSelectorState {
  const factory _ProxiesListSelectorState(
      {required final List<String> groupNames,
      required final Set<String> currentUnfoldSet,
      required final ProxiesSortType proxiesSortType,
      required final ProxyCardType proxyCardType,
      required final num sortNum,
      required final int columns}) = _$ProxiesListSelectorStateImpl;

  @override
  List<String> get groupNames;
  @override
  Set<String> get currentUnfoldSet;
  @override
  ProxiesSortType get proxiesSortType;
  @override
  ProxyCardType get proxyCardType;
  @override
  num get sortNum;
  @override
  int get columns;
  @override
  @JsonKey(ignore: true)
  _$$ProxiesListSelectorStateImplCopyWith<_$ProxiesListSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxyGroupSelectorState {
  ProxiesSortType get proxiesSortType => throw _privateConstructorUsedError;
  ProxyCardType get proxyCardType => throw _privateConstructorUsedError;
  num get sortNum => throw _privateConstructorUsedError;
  GroupType get groupType => throw _privateConstructorUsedError;
  List<Proxy> get proxies => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxyGroupSelectorStateCopyWith<ProxyGroupSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxyGroupSelectorStateCopyWith<$Res> {
  factory $ProxyGroupSelectorStateCopyWith(ProxyGroupSelectorState value,
          $Res Function(ProxyGroupSelectorState) then) =
      _$ProxyGroupSelectorStateCopyWithImpl<$Res, ProxyGroupSelectorState>;
  @useResult
  $Res call(
      {ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      GroupType groupType,
      List<Proxy> proxies,
      int columns});
}

/// @nodoc
class _$ProxyGroupSelectorStateCopyWithImpl<$Res,
        $Val extends ProxyGroupSelectorState>
    implements $ProxyGroupSelectorStateCopyWith<$Res> {
  _$ProxyGroupSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? groupType = null,
    Object? proxies = null,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      groupType: null == groupType
          ? _value.groupType
          : groupType // ignore: cast_nullable_to_non_nullable
              as GroupType,
      proxies: null == proxies
          ? _value.proxies
          : proxies // ignore: cast_nullable_to_non_nullable
              as List<Proxy>,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxyGroupSelectorStateImplCopyWith<$Res>
    implements $ProxyGroupSelectorStateCopyWith<$Res> {
  factory _$$ProxyGroupSelectorStateImplCopyWith(
          _$ProxyGroupSelectorStateImpl value,
          $Res Function(_$ProxyGroupSelectorStateImpl) then) =
      __$$ProxyGroupSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      GroupType groupType,
      List<Proxy> proxies,
      int columns});
}

/// @nodoc
class __$$ProxyGroupSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxyGroupSelectorStateCopyWithImpl<$Res,
        _$ProxyGroupSelectorStateImpl>
    implements _$$ProxyGroupSelectorStateImplCopyWith<$Res> {
  __$$ProxyGroupSelectorStateImplCopyWithImpl(
      _$ProxyGroupSelectorStateImpl _value,
      $Res Function(_$ProxyGroupSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? groupType = null,
    Object? proxies = null,
    Object? columns = null,
  }) {
    return _then(_$ProxyGroupSelectorStateImpl(
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      groupType: null == groupType
          ? _value.groupType
          : groupType // ignore: cast_nullable_to_non_nullable
              as GroupType,
      proxies: null == proxies
          ? _value._proxies
          : proxies // ignore: cast_nullable_to_non_nullable
              as List<Proxy>,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxyGroupSelectorStateImpl implements _ProxyGroupSelectorState {
  const _$ProxyGroupSelectorStateImpl(
      {required this.proxiesSortType,
      required this.proxyCardType,
      required this.sortNum,
      required this.groupType,
      required final List<Proxy> proxies,
      required this.columns})
      : _proxies = proxies;

  @override
  final ProxiesSortType proxiesSortType;
  @override
  final ProxyCardType proxyCardType;
  @override
  final num sortNum;
  @override
  final GroupType groupType;
  final List<Proxy> _proxies;
  @override
  List<Proxy> get proxies {
    if (_proxies is EqualUnmodifiableListView) return _proxies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_proxies);
  }

  @override
  final int columns;

  @override
  String toString() {
    return 'ProxyGroupSelectorState(proxiesSortType: $proxiesSortType, proxyCardType: $proxyCardType, sortNum: $sortNum, groupType: $groupType, proxies: $proxies, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxyGroupSelectorStateImpl &&
            (identical(other.proxiesSortType, proxiesSortType) ||
                other.proxiesSortType == proxiesSortType) &&
            (identical(other.proxyCardType, proxyCardType) ||
                other.proxyCardType == proxyCardType) &&
            (identical(other.sortNum, sortNum) || other.sortNum == sortNum) &&
            (identical(other.groupType, groupType) ||
                other.groupType == groupType) &&
            const DeepCollectionEquality().equals(other._proxies, _proxies) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      proxiesSortType,
      proxyCardType,
      sortNum,
      groupType,
      const DeepCollectionEquality().hash(_proxies),
      columns);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxyGroupSelectorStateImplCopyWith<_$ProxyGroupSelectorStateImpl>
      get copyWith => __$$ProxyGroupSelectorStateImplCopyWithImpl<
          _$ProxyGroupSelectorStateImpl>(this, _$identity);
}

abstract class _ProxyGroupSelectorState implements ProxyGroupSelectorState {
  const factory _ProxyGroupSelectorState(
      {required final ProxiesSortType proxiesSortType,
      required final ProxyCardType proxyCardType,
      required final num sortNum,
      required final GroupType groupType,
      required final List<Proxy> proxies,
      required final int columns}) = _$ProxyGroupSelectorStateImpl;

  @override
  ProxiesSortType get proxiesSortType;
  @override
  ProxyCardType get proxyCardType;
  @override
  num get sortNum;
  @override
  GroupType get groupType;
  @override
  List<Proxy> get proxies;
  @override
  int get columns;
  @override
  @JsonKey(ignore: true)
  _$$ProxyGroupSelectorStateImplCopyWith<_$ProxyGroupSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MoreToolsSelectorState {
  List<NavigationItem> get navigationItems =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MoreToolsSelectorStateCopyWith<MoreToolsSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MoreToolsSelectorStateCopyWith<$Res> {
  factory $MoreToolsSelectorStateCopyWith(MoreToolsSelectorState value,
          $Res Function(MoreToolsSelectorState) then) =
      _$MoreToolsSelectorStateCopyWithImpl<$Res, MoreToolsSelectorState>;
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class _$MoreToolsSelectorStateCopyWithImpl<$Res,
        $Val extends MoreToolsSelectorState>
    implements $MoreToolsSelectorStateCopyWith<$Res> {
  _$MoreToolsSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_value.copyWith(
      navigationItems: null == navigationItems
          ? _value.navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MoreToolsSelectorStateImplCopyWith<$Res>
    implements $MoreToolsSelectorStateCopyWith<$Res> {
  factory _$$MoreToolsSelectorStateImplCopyWith(
          _$MoreToolsSelectorStateImpl value,
          $Res Function(_$MoreToolsSelectorStateImpl) then) =
      __$$MoreToolsSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class __$$MoreToolsSelectorStateImplCopyWithImpl<$Res>
    extends _$MoreToolsSelectorStateCopyWithImpl<$Res,
        _$MoreToolsSelectorStateImpl>
    implements _$$MoreToolsSelectorStateImplCopyWith<$Res> {
  __$$MoreToolsSelectorStateImplCopyWithImpl(
      _$MoreToolsSelectorStateImpl _value,
      $Res Function(_$MoreToolsSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_$MoreToolsSelectorStateImpl(
      navigationItems: null == navigationItems
          ? _value._navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ));
  }
}

/// @nodoc

class _$MoreToolsSelectorStateImpl implements _MoreToolsSelectorState {
  const _$MoreToolsSelectorStateImpl(
      {required final List<NavigationItem> navigationItems})
      : _navigationItems = navigationItems;

  final List<NavigationItem> _navigationItems;
  @override
  List<NavigationItem> get navigationItems {
    if (_navigationItems is EqualUnmodifiableListView) return _navigationItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_navigationItems);
  }

  @override
  String toString() {
    return 'MoreToolsSelectorState(navigationItems: $navigationItems)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MoreToolsSelectorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._navigationItems, _navigationItems));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_navigationItems));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MoreToolsSelectorStateImplCopyWith<_$MoreToolsSelectorStateImpl>
      get copyWith => __$$MoreToolsSelectorStateImplCopyWithImpl<
          _$MoreToolsSelectorStateImpl>(this, _$identity);
}

abstract class _MoreToolsSelectorState implements MoreToolsSelectorState {
  const factory _MoreToolsSelectorState(
          {required final List<NavigationItem> navigationItems}) =
      _$MoreToolsSelectorStateImpl;

  @override
  List<NavigationItem> get navigationItems;
  @override
  @JsonKey(ignore: true)
  _$$MoreToolsSelectorStateImplCopyWith<_$MoreToolsSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PackageListSelectorState {
  List<Package> get packages => throw _privateConstructorUsedError;
  AccessControl get accessControl => throw _privateConstructorUsedError;
  bool get isAccessControl => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PackageListSelectorStateCopyWith<PackageListSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackageListSelectorStateCopyWith<$Res> {
  factory $PackageListSelectorStateCopyWith(PackageListSelectorState value,
          $Res Function(PackageListSelectorState) then) =
      _$PackageListSelectorStateCopyWithImpl<$Res, PackageListSelectorState>;
  @useResult
  $Res call(
      {List<Package> packages,
      AccessControl accessControl,
      bool isAccessControl});

  $AccessControlCopyWith<$Res> get accessControl;
}

/// @nodoc
class _$PackageListSelectorStateCopyWithImpl<$Res,
        $Val extends PackageListSelectorState>
    implements $PackageListSelectorStateCopyWith<$Res> {
  _$PackageListSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? packages = null,
    Object? accessControl = null,
    Object? isAccessControl = null,
  }) {
    return _then(_value.copyWith(
      packages: null == packages
          ? _value.packages
          : packages // ignore: cast_nullable_to_non_nullable
              as List<Package>,
      accessControl: null == accessControl
          ? _value.accessControl
          : accessControl // ignore: cast_nullable_to_non_nullable
              as AccessControl,
      isAccessControl: null == isAccessControl
          ? _value.isAccessControl
          : isAccessControl // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AccessControlCopyWith<$Res> get accessControl {
    return $AccessControlCopyWith<$Res>(_value.accessControl, (value) {
      return _then(_value.copyWith(accessControl: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PackageListSelectorStateImplCopyWith<$Res>
    implements $PackageListSelectorStateCopyWith<$Res> {
  factory _$$PackageListSelectorStateImplCopyWith(
          _$PackageListSelectorStateImpl value,
          $Res Function(_$PackageListSelectorStateImpl) then) =
      __$$PackageListSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Package> packages,
      AccessControl accessControl,
      bool isAccessControl});

  @override
  $AccessControlCopyWith<$Res> get accessControl;
}

/// @nodoc
class __$$PackageListSelectorStateImplCopyWithImpl<$Res>
    extends _$PackageListSelectorStateCopyWithImpl<$Res,
        _$PackageListSelectorStateImpl>
    implements _$$PackageListSelectorStateImplCopyWith<$Res> {
  __$$PackageListSelectorStateImplCopyWithImpl(
      _$PackageListSelectorStateImpl _value,
      $Res Function(_$PackageListSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? packages = null,
    Object? accessControl = null,
    Object? isAccessControl = null,
  }) {
    return _then(_$PackageListSelectorStateImpl(
      packages: null == packages
          ? _value._packages
          : packages // ignore: cast_nullable_to_non_nullable
              as List<Package>,
      accessControl: null == accessControl
          ? _value.accessControl
          : accessControl // ignore: cast_nullable_to_non_nullable
              as AccessControl,
      isAccessControl: null == isAccessControl
          ? _value.isAccessControl
          : isAccessControl // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$PackageListSelectorStateImpl implements _PackageListSelectorState {
  const _$PackageListSelectorStateImpl(
      {required final List<Package> packages,
      required this.accessControl,
      required this.isAccessControl})
      : _packages = packages;

  final List<Package> _packages;
  @override
  List<Package> get packages {
    if (_packages is EqualUnmodifiableListView) return _packages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_packages);
  }

  @override
  final AccessControl accessControl;
  @override
  final bool isAccessControl;

  @override
  String toString() {
    return 'PackageListSelectorState(packages: $packages, accessControl: $accessControl, isAccessControl: $isAccessControl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PackageListSelectorStateImpl &&
            const DeepCollectionEquality().equals(other._packages, _packages) &&
            (identical(other.accessControl, accessControl) ||
                other.accessControl == accessControl) &&
            (identical(other.isAccessControl, isAccessControl) ||
                other.isAccessControl == isAccessControl));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_packages),
      accessControl,
      isAccessControl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PackageListSelectorStateImplCopyWith<_$PackageListSelectorStateImpl>
      get copyWith => __$$PackageListSelectorStateImplCopyWithImpl<
          _$PackageListSelectorStateImpl>(this, _$identity);
}

abstract class _PackageListSelectorState implements PackageListSelectorState {
  const factory _PackageListSelectorState(
      {required final List<Package> packages,
      required final AccessControl accessControl,
      required final bool isAccessControl}) = _$PackageListSelectorStateImpl;

  @override
  List<Package> get packages;
  @override
  AccessControl get accessControl;
  @override
  bool get isAccessControl;
  @override
  @JsonKey(ignore: true)
  _$$PackageListSelectorStateImplCopyWith<_$PackageListSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesListHeaderSelectorState {
  double get offset => throw _privateConstructorUsedError;
  int get currentIndex => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxiesListHeaderSelectorStateCopyWith<ProxiesListHeaderSelectorState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  factory $ProxiesListHeaderSelectorStateCopyWith(
          ProxiesListHeaderSelectorState value,
          $Res Function(ProxiesListHeaderSelectorState) then) =
      _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
          ProxiesListHeaderSelectorState>;
  @useResult
  $Res call({double offset, int currentIndex});
}

/// @nodoc
class _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
        $Val extends ProxiesListHeaderSelectorState>
    implements $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  _$ProxiesListHeaderSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? currentIndex = null,
  }) {
    return _then(_value.copyWith(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as double,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesListHeaderSelectorStateImplCopyWith<$Res>
    implements $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  factory _$$ProxiesListHeaderSelectorStateImplCopyWith(
          _$ProxiesListHeaderSelectorStateImpl value,
          $Res Function(_$ProxiesListHeaderSelectorStateImpl) then) =
      __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double offset, int currentIndex});
}

/// @nodoc
class __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
        _$ProxiesListHeaderSelectorStateImpl>
    implements _$$ProxiesListHeaderSelectorStateImplCopyWith<$Res> {
  __$$ProxiesListHeaderSelectorStateImplCopyWithImpl(
      _$ProxiesListHeaderSelectorStateImpl _value,
      $Res Function(_$ProxiesListHeaderSelectorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? currentIndex = null,
  }) {
    return _then(_$ProxiesListHeaderSelectorStateImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as double,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxiesListHeaderSelectorStateImpl
    implements _ProxiesListHeaderSelectorState {
  const _$ProxiesListHeaderSelectorStateImpl(
      {required this.offset, required this.currentIndex});

  @override
  final double offset;
  @override
  final int currentIndex;

  @override
  String toString() {
    return 'ProxiesListHeaderSelectorState(offset: $offset, currentIndex: $currentIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesListHeaderSelectorStateImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.currentIndex, currentIndex) ||
                other.currentIndex == currentIndex));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, currentIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesListHeaderSelectorStateImplCopyWith<
          _$ProxiesListHeaderSelectorStateImpl>
      get copyWith => __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<
          _$ProxiesListHeaderSelectorStateImpl>(this, _$identity);
}

abstract class _ProxiesListHeaderSelectorState
    implements ProxiesListHeaderSelectorState {
  const factory _ProxiesListHeaderSelectorState(
      {required final double offset,
      required final int currentIndex}) = _$ProxiesListHeaderSelectorStateImpl;

  @override
  double get offset;
  @override
  int get currentIndex;
  @override
  @JsonKey(ignore: true)
  _$$ProxiesListHeaderSelectorStateImplCopyWith<
          _$ProxiesListHeaderSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesActionsState {
  bool get isCurrent => throw _privateConstructorUsedError;
  bool get hasProvider => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxiesActionsStateCopyWith<ProxiesActionsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesActionsStateCopyWith<$Res> {
  factory $ProxiesActionsStateCopyWith(
          ProxiesActionsState value, $Res Function(ProxiesActionsState) then) =
      _$ProxiesActionsStateCopyWithImpl<$Res, ProxiesActionsState>;
  @useResult
  $Res call({bool isCurrent, bool hasProvider});
}

/// @nodoc
class _$ProxiesActionsStateCopyWithImpl<$Res, $Val extends ProxiesActionsState>
    implements $ProxiesActionsStateCopyWith<$Res> {
  _$ProxiesActionsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isCurrent = null,
    Object? hasProvider = null,
  }) {
    return _then(_value.copyWith(
      isCurrent: null == isCurrent
          ? _value.isCurrent
          : isCurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProvider: null == hasProvider
          ? _value.hasProvider
          : hasProvider // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesActionsStateImplCopyWith<$Res>
    implements $ProxiesActionsStateCopyWith<$Res> {
  factory _$$ProxiesActionsStateImplCopyWith(_$ProxiesActionsStateImpl value,
          $Res Function(_$ProxiesActionsStateImpl) then) =
      __$$ProxiesActionsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isCurrent, bool hasProvider});
}

/// @nodoc
class __$$ProxiesActionsStateImplCopyWithImpl<$Res>
    extends _$ProxiesActionsStateCopyWithImpl<$Res, _$ProxiesActionsStateImpl>
    implements _$$ProxiesActionsStateImplCopyWith<$Res> {
  __$$ProxiesActionsStateImplCopyWithImpl(_$ProxiesActionsStateImpl _value,
      $Res Function(_$ProxiesActionsStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isCurrent = null,
    Object? hasProvider = null,
  }) {
    return _then(_$ProxiesActionsStateImpl(
      isCurrent: null == isCurrent
          ? _value.isCurrent
          : isCurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProvider: null == hasProvider
          ? _value.hasProvider
          : hasProvider // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProxiesActionsStateImpl implements _ProxiesActionsState {
  const _$ProxiesActionsStateImpl(
      {required this.isCurrent, required this.hasProvider});

  @override
  final bool isCurrent;
  @override
  final bool hasProvider;

  @override
  String toString() {
    return 'ProxiesActionsState(isCurrent: $isCurrent, hasProvider: $hasProvider)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesActionsStateImpl &&
            (identical(other.isCurrent, isCurrent) ||
                other.isCurrent == isCurrent) &&
            (identical(other.hasProvider, hasProvider) ||
                other.hasProvider == hasProvider));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isCurrent, hasProvider);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesActionsStateImplCopyWith<_$ProxiesActionsStateImpl> get copyWith =>
      __$$ProxiesActionsStateImplCopyWithImpl<_$ProxiesActionsStateImpl>(
          this, _$identity);
}

abstract class _ProxiesActionsState implements ProxiesActionsState {
  const factory _ProxiesActionsState(
      {required final bool isCurrent,
      required final bool hasProvider}) = _$ProxiesActionsStateImpl;

  @override
  bool get isCurrent;
  @override
  bool get hasProvider;
  @override
  @JsonKey(ignore: true)
  _$$ProxiesActionsStateImplCopyWith<_$ProxiesActionsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AutoLaunchState {
  bool get isAutoLaunch => throw _privateConstructorUsedError;
  bool get isOpenTun => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AutoLaunchStateCopyWith<AutoLaunchState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AutoLaunchStateCopyWith<$Res> {
  factory $AutoLaunchStateCopyWith(
          AutoLaunchState value, $Res Function(AutoLaunchState) then) =
      _$AutoLaunchStateCopyWithImpl<$Res, AutoLaunchState>;
  @useResult
  $Res call({bool isAutoLaunch, bool isOpenTun});
}

/// @nodoc
class _$AutoLaunchStateCopyWithImpl<$Res, $Val extends AutoLaunchState>
    implements $AutoLaunchStateCopyWith<$Res> {
  _$AutoLaunchStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isAutoLaunch = null,
    Object? isOpenTun = null,
  }) {
    return _then(_value.copyWith(
      isAutoLaunch: null == isAutoLaunch
          ? _value.isAutoLaunch
          : isAutoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      isOpenTun: null == isOpenTun
          ? _value.isOpenTun
          : isOpenTun // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AutoLaunchStateImplCopyWith<$Res>
    implements $AutoLaunchStateCopyWith<$Res> {
  factory _$$AutoLaunchStateImplCopyWith(_$AutoLaunchStateImpl value,
          $Res Function(_$AutoLaunchStateImpl) then) =
      __$$AutoLaunchStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isAutoLaunch, bool isOpenTun});
}

/// @nodoc
class __$$AutoLaunchStateImplCopyWithImpl<$Res>
    extends _$AutoLaunchStateCopyWithImpl<$Res, _$AutoLaunchStateImpl>
    implements _$$AutoLaunchStateImplCopyWith<$Res> {
  __$$AutoLaunchStateImplCopyWithImpl(
      _$AutoLaunchStateImpl _value, $Res Function(_$AutoLaunchStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isAutoLaunch = null,
    Object? isOpenTun = null,
  }) {
    return _then(_$AutoLaunchStateImpl(
      isAutoLaunch: null == isAutoLaunch
          ? _value.isAutoLaunch
          : isAutoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      isOpenTun: null == isOpenTun
          ? _value.isOpenTun
          : isOpenTun // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$AutoLaunchStateImpl implements _AutoLaunchState {
  const _$AutoLaunchStateImpl(
      {required this.isAutoLaunch, required this.isOpenTun});

  @override
  final bool isAutoLaunch;
  @override
  final bool isOpenTun;

  @override
  String toString() {
    return 'AutoLaunchState(isAutoLaunch: $isAutoLaunch, isOpenTun: $isOpenTun)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutoLaunchStateImpl &&
            (identical(other.isAutoLaunch, isAutoLaunch) ||
                other.isAutoLaunch == isAutoLaunch) &&
            (identical(other.isOpenTun, isOpenTun) ||
                other.isOpenTun == isOpenTun));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isAutoLaunch, isOpenTun);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AutoLaunchStateImplCopyWith<_$AutoLaunchStateImpl> get copyWith =>
      __$$AutoLaunchStateImplCopyWithImpl<_$AutoLaunchStateImpl>(
          this, _$identity);
}

abstract class _AutoLaunchState implements AutoLaunchState {
  const factory _AutoLaunchState(
      {required final bool isAutoLaunch,
      required final bool isOpenTun}) = _$AutoLaunchStateImpl;

  @override
  bool get isAutoLaunch;
  @override
  bool get isOpenTun;
  @override
  @JsonKey(ignore: true)
  _$$AutoLaunchStateImplCopyWith<_$AutoLaunchStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxyState {
  bool get isStart => throw _privateConstructorUsedError;
  bool get systemProxy => throw _privateConstructorUsedError;
  int get port => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProxyStateCopyWith<ProxyState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxyStateCopyWith<$Res> {
  factory $ProxyStateCopyWith(
          ProxyState value, $Res Function(ProxyState) then) =
      _$ProxyStateCopyWithImpl<$Res, ProxyState>;
  @useResult
  $Res call({bool isStart, bool systemProxy, int port});
}

/// @nodoc
class _$ProxyStateCopyWithImpl<$Res, $Val extends ProxyState>
    implements $ProxyStateCopyWith<$Res> {
  _$ProxyStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isStart = null,
    Object? systemProxy = null,
    Object? port = null,
  }) {
    return _then(_value.copyWith(
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxyStateImplCopyWith<$Res>
    implements $ProxyStateCopyWith<$Res> {
  factory _$$ProxyStateImplCopyWith(
          _$ProxyStateImpl value, $Res Function(_$ProxyStateImpl) then) =
      __$$ProxyStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isStart, bool systemProxy, int port});
}

/// @nodoc
class __$$ProxyStateImplCopyWithImpl<$Res>
    extends _$ProxyStateCopyWithImpl<$Res, _$ProxyStateImpl>
    implements _$$ProxyStateImplCopyWith<$Res> {
  __$$ProxyStateImplCopyWithImpl(
      _$ProxyStateImpl _value, $Res Function(_$ProxyStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isStart = null,
    Object? systemProxy = null,
    Object? port = null,
  }) {
    return _then(_$ProxyStateImpl(
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxyStateImpl implements _ProxyState {
  const _$ProxyStateImpl(
      {required this.isStart, required this.systemProxy, required this.port});

  @override
  final bool isStart;
  @override
  final bool systemProxy;
  @override
  final int port;

  @override
  String toString() {
    return 'ProxyState(isStart: $isStart, systemProxy: $systemProxy, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxyStateImpl &&
            (identical(other.isStart, isStart) || other.isStart == isStart) &&
            (identical(other.systemProxy, systemProxy) ||
                other.systemProxy == systemProxy) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isStart, systemProxy, port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxyStateImplCopyWith<_$ProxyStateImpl> get copyWith =>
      __$$ProxyStateImplCopyWithImpl<_$ProxyStateImpl>(this, _$identity);
}

abstract class _ProxyState implements ProxyState {
  const factory _ProxyState(
      {required final bool isStart,
      required final bool systemProxy,
      required final int port}) = _$ProxyStateImpl;

  @override
  bool get isStart;
  @override
  bool get systemProxy;
  @override
  int get port;
  @override
  @JsonKey(ignore: true)
  _$$ProxyStateImplCopyWith<_$ProxyStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ClashConfigState {
  int get mixedPort => throw _privateConstructorUsedError;
  bool get allowLan => throw _privateConstructorUsedError;
  bool get ipv6 => throw _privateConstructorUsedError;
  String get geodataLoader => throw _privateConstructorUsedError;
  LogLevel get logLevel => throw _privateConstructorUsedError;
  String get externalController => throw _privateConstructorUsedError;
  Mode get mode => throw _privateConstructorUsedError;
  FindProcessMode get findProcessMode => throw _privateConstructorUsedError;
  int get keepAliveInterval => throw _privateConstructorUsedError;
  bool get unifiedDelay => throw _privateConstructorUsedError;
  bool get tcpConcurrent => throw _privateConstructorUsedError;
  Tun get tun => throw _privateConstructorUsedError;
  Dns get dns => throw _privateConstructorUsedError;
  Map<String, String> get geoXUrl => throw _privateConstructorUsedError;
  List<String> get rules => throw _privateConstructorUsedError;
  String? get globalRealUa => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ClashConfigStateCopyWith<ClashConfigState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClashConfigStateCopyWith<$Res> {
  factory $ClashConfigStateCopyWith(
          ClashConfigState value, $Res Function(ClashConfigState) then) =
      _$ClashConfigStateCopyWithImpl<$Res, ClashConfigState>;
  @useResult
  $Res call(
      {int mixedPort,
      bool allowLan,
      bool ipv6,
      String geodataLoader,
      LogLevel logLevel,
      String externalController,
      Mode mode,
      FindProcessMode findProcessMode,
      int keepAliveInterval,
      bool unifiedDelay,
      bool tcpConcurrent,
      Tun tun,
      Dns dns,
      Map<String, String> geoXUrl,
      List<String> rules,
      String? globalRealUa});

  $TunCopyWith<$Res> get tun;
}

/// @nodoc
class _$ClashConfigStateCopyWithImpl<$Res, $Val extends ClashConfigState>
    implements $ClashConfigStateCopyWith<$Res> {
  _$ClashConfigStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mixedPort = null,
    Object? allowLan = null,
    Object? ipv6 = null,
    Object? geodataLoader = null,
    Object? logLevel = null,
    Object? externalController = null,
    Object? mode = null,
    Object? findProcessMode = null,
    Object? keepAliveInterval = null,
    Object? unifiedDelay = null,
    Object? tcpConcurrent = null,
    Object? tun = null,
    Object? dns = null,
    Object? geoXUrl = null,
    Object? rules = null,
    Object? globalRealUa = freezed,
  }) {
    return _then(_value.copyWith(
      mixedPort: null == mixedPort
          ? _value.mixedPort
          : mixedPort // ignore: cast_nullable_to_non_nullable
              as int,
      allowLan: null == allowLan
          ? _value.allowLan
          : allowLan // ignore: cast_nullable_to_non_nullable
              as bool,
      ipv6: null == ipv6
          ? _value.ipv6
          : ipv6 // ignore: cast_nullable_to_non_nullable
              as bool,
      geodataLoader: null == geodataLoader
          ? _value.geodataLoader
          : geodataLoader // ignore: cast_nullable_to_non_nullable
              as String,
      logLevel: null == logLevel
          ? _value.logLevel
          : logLevel // ignore: cast_nullable_to_non_nullable
              as LogLevel,
      externalController: null == externalController
          ? _value.externalController
          : externalController // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      findProcessMode: null == findProcessMode
          ? _value.findProcessMode
          : findProcessMode // ignore: cast_nullable_to_non_nullable
              as FindProcessMode,
      keepAliveInterval: null == keepAliveInterval
          ? _value.keepAliveInterval
          : keepAliveInterval // ignore: cast_nullable_to_non_nullable
              as int,
      unifiedDelay: null == unifiedDelay
          ? _value.unifiedDelay
          : unifiedDelay // ignore: cast_nullable_to_non_nullable
              as bool,
      tcpConcurrent: null == tcpConcurrent
          ? _value.tcpConcurrent
          : tcpConcurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      tun: null == tun
          ? _value.tun
          : tun // ignore: cast_nullable_to_non_nullable
              as Tun,
      dns: null == dns
          ? _value.dns
          : dns // ignore: cast_nullable_to_non_nullable
              as Dns,
      geoXUrl: null == geoXUrl
          ? _value.geoXUrl
          : geoXUrl // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      rules: null == rules
          ? _value.rules
          : rules // ignore: cast_nullable_to_non_nullable
              as List<String>,
      globalRealUa: freezed == globalRealUa
          ? _value.globalRealUa
          : globalRealUa // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TunCopyWith<$Res> get tun {
    return $TunCopyWith<$Res>(_value.tun, (value) {
      return _then(_value.copyWith(tun: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ClashConfigStateImplCopyWith<$Res>
    implements $ClashConfigStateCopyWith<$Res> {
  factory _$$ClashConfigStateImplCopyWith(_$ClashConfigStateImpl value,
          $Res Function(_$ClashConfigStateImpl) then) =
      __$$ClashConfigStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int mixedPort,
      bool allowLan,
      bool ipv6,
      String geodataLoader,
      LogLevel logLevel,
      String externalController,
      Mode mode,
      FindProcessMode findProcessMode,
      int keepAliveInterval,
      bool unifiedDelay,
      bool tcpConcurrent,
      Tun tun,
      Dns dns,
      Map<String, String> geoXUrl,
      List<String> rules,
      String? globalRealUa});

  @override
  $TunCopyWith<$Res> get tun;
}

/// @nodoc
class __$$ClashConfigStateImplCopyWithImpl<$Res>
    extends _$ClashConfigStateCopyWithImpl<$Res, _$ClashConfigStateImpl>
    implements _$$ClashConfigStateImplCopyWith<$Res> {
  __$$ClashConfigStateImplCopyWithImpl(_$ClashConfigStateImpl _value,
      $Res Function(_$ClashConfigStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mixedPort = null,
    Object? allowLan = null,
    Object? ipv6 = null,
    Object? geodataLoader = null,
    Object? logLevel = null,
    Object? externalController = null,
    Object? mode = null,
    Object? findProcessMode = null,
    Object? keepAliveInterval = null,
    Object? unifiedDelay = null,
    Object? tcpConcurrent = null,
    Object? tun = null,
    Object? dns = null,
    Object? geoXUrl = null,
    Object? rules = null,
    Object? globalRealUa = freezed,
  }) {
    return _then(_$ClashConfigStateImpl(
      mixedPort: null == mixedPort
          ? _value.mixedPort
          : mixedPort // ignore: cast_nullable_to_non_nullable
              as int,
      allowLan: null == allowLan
          ? _value.allowLan
          : allowLan // ignore: cast_nullable_to_non_nullable
              as bool,
      ipv6: null == ipv6
          ? _value.ipv6
          : ipv6 // ignore: cast_nullable_to_non_nullable
              as bool,
      geodataLoader: null == geodataLoader
          ? _value.geodataLoader
          : geodataLoader // ignore: cast_nullable_to_non_nullable
              as String,
      logLevel: null == logLevel
          ? _value.logLevel
          : logLevel // ignore: cast_nullable_to_non_nullable
              as LogLevel,
      externalController: null == externalController
          ? _value.externalController
          : externalController // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      findProcessMode: null == findProcessMode
          ? _value.findProcessMode
          : findProcessMode // ignore: cast_nullable_to_non_nullable
              as FindProcessMode,
      keepAliveInterval: null == keepAliveInterval
          ? _value.keepAliveInterval
          : keepAliveInterval // ignore: cast_nullable_to_non_nullable
              as int,
      unifiedDelay: null == unifiedDelay
          ? _value.unifiedDelay
          : unifiedDelay // ignore: cast_nullable_to_non_nullable
              as bool,
      tcpConcurrent: null == tcpConcurrent
          ? _value.tcpConcurrent
          : tcpConcurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      tun: null == tun
          ? _value.tun
          : tun // ignore: cast_nullable_to_non_nullable
              as Tun,
      dns: null == dns
          ? _value.dns
          : dns // ignore: cast_nullable_to_non_nullable
              as Dns,
      geoXUrl: null == geoXUrl
          ? _value._geoXUrl
          : geoXUrl // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      rules: null == rules
          ? _value._rules
          : rules // ignore: cast_nullable_to_non_nullable
              as List<String>,
      globalRealUa: freezed == globalRealUa
          ? _value.globalRealUa
          : globalRealUa // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ClashConfigStateImpl implements _ClashConfigState {
  const _$ClashConfigStateImpl(
      {required this.mixedPort,
      required this.allowLan,
      required this.ipv6,
      required this.geodataLoader,
      required this.logLevel,
      required this.externalController,
      required this.mode,
      required this.findProcessMode,
      required this.keepAliveInterval,
      required this.unifiedDelay,
      required this.tcpConcurrent,
      required this.tun,
      required this.dns,
      required final Map<String, String> geoXUrl,
      required final List<String> rules,
      required this.globalRealUa})
      : _geoXUrl = geoXUrl,
        _rules = rules;

  @override
  final int mixedPort;
  @override
  final bool allowLan;
  @override
  final bool ipv6;
  @override
  final String geodataLoader;
  @override
  final LogLevel logLevel;
  @override
  final String externalController;
  @override
  final Mode mode;
  @override
  final FindProcessMode findProcessMode;
  @override
  final int keepAliveInterval;
  @override
  final bool unifiedDelay;
  @override
  final bool tcpConcurrent;
  @override
  final Tun tun;
  @override
  final Dns dns;
  final Map<String, String> _geoXUrl;
  @override
  Map<String, String> get geoXUrl {
    if (_geoXUrl is EqualUnmodifiableMapView) return _geoXUrl;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_geoXUrl);
  }

  final List<String> _rules;
  @override
  List<String> get rules {
    if (_rules is EqualUnmodifiableListView) return _rules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_rules);
  }

  @override
  final String? globalRealUa;

  @override
  String toString() {
    return 'ClashConfigState(mixedPort: $mixedPort, allowLan: $allowLan, ipv6: $ipv6, geodataLoader: $geodataLoader, logLevel: $logLevel, externalController: $externalController, mode: $mode, findProcessMode: $findProcessMode, keepAliveInterval: $keepAliveInterval, unifiedDelay: $unifiedDelay, tcpConcurrent: $tcpConcurrent, tun: $tun, dns: $dns, geoXUrl: $geoXUrl, rules: $rules, globalRealUa: $globalRealUa)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClashConfigStateImpl &&
            (identical(other.mixedPort, mixedPort) ||
                other.mixedPort == mixedPort) &&
            (identical(other.allowLan, allowLan) ||
                other.allowLan == allowLan) &&
            (identical(other.ipv6, ipv6) || other.ipv6 == ipv6) &&
            (identical(other.geodataLoader, geodataLoader) ||
                other.geodataLoader == geodataLoader) &&
            (identical(other.logLevel, logLevel) ||
                other.logLevel == logLevel) &&
            (identical(other.externalController, externalController) ||
                other.externalController == externalController) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.findProcessMode, findProcessMode) ||
                other.findProcessMode == findProcessMode) &&
            (identical(other.keepAliveInterval, keepAliveInterval) ||
                other.keepAliveInterval == keepAliveInterval) &&
            (identical(other.unifiedDelay, unifiedDelay) ||
                other.unifiedDelay == unifiedDelay) &&
            (identical(other.tcpConcurrent, tcpConcurrent) ||
                other.tcpConcurrent == tcpConcurrent) &&
            (identical(other.tun, tun) || other.tun == tun) &&
            (identical(other.dns, dns) || other.dns == dns) &&
            const DeepCollectionEquality().equals(other._geoXUrl, _geoXUrl) &&
            const DeepCollectionEquality().equals(other._rules, _rules) &&
            (identical(other.globalRealUa, globalRealUa) ||
                other.globalRealUa == globalRealUa));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      mixedPort,
      allowLan,
      ipv6,
      geodataLoader,
      logLevel,
      externalController,
      mode,
      findProcessMode,
      keepAliveInterval,
      unifiedDelay,
      tcpConcurrent,
      tun,
      dns,
      const DeepCollectionEquality().hash(_geoXUrl),
      const DeepCollectionEquality().hash(_rules),
      globalRealUa);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClashConfigStateImplCopyWith<_$ClashConfigStateImpl> get copyWith =>
      __$$ClashConfigStateImplCopyWithImpl<_$ClashConfigStateImpl>(
          this, _$identity);
}

abstract class _ClashConfigState implements ClashConfigState {
  const factory _ClashConfigState(
      {required final int mixedPort,
      required final bool allowLan,
      required final bool ipv6,
      required final String geodataLoader,
      required final LogLevel logLevel,
      required final String externalController,
      required final Mode mode,
      required final FindProcessMode findProcessMode,
      required final int keepAliveInterval,
      required final bool unifiedDelay,
      required final bool tcpConcurrent,
      required final Tun tun,
      required final Dns dns,
      required final Map<String, String> geoXUrl,
      required final List<String> rules,
      required final String? globalRealUa}) = _$ClashConfigStateImpl;

  @override
  int get mixedPort;
  @override
  bool get allowLan;
  @override
  bool get ipv6;
  @override
  String get geodataLoader;
  @override
  LogLevel get logLevel;
  @override
  String get externalController;
  @override
  Mode get mode;
  @override
  FindProcessMode get findProcessMode;
  @override
  int get keepAliveInterval;
  @override
  bool get unifiedDelay;
  @override
  bool get tcpConcurrent;
  @override
  Tun get tun;
  @override
  Dns get dns;
  @override
  Map<String, String> get geoXUrl;
  @override
  List<String> get rules;
  @override
  String? get globalRealUa;
  @override
  @JsonKey(ignore: true)
  _$$ClashConfigStateImplCopyWith<_$ClashConfigStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
